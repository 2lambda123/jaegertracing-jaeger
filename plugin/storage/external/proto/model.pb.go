// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model.proto

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SpanRefType int32

const (
	SpanRefType_SpanRefType_CHILD_OF     SpanRefType = 0
	SpanRefType_SpanRefType_FOLLOWS_FROM SpanRefType = 1
)

var SpanRefType_name = map[int32]string{
	0: "SpanRefType_CHILD_OF",
	1: "SpanRefType_FOLLOWS_FROM",
}
var SpanRefType_value = map[string]int32{
	"SpanRefType_CHILD_OF":     0,
	"SpanRefType_FOLLOWS_FROM": 1,
}

func (x SpanRefType) String() string {
	return proto1.EnumName(SpanRefType_name, int32(x))
}
func (SpanRefType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type ValueType int32

const (
	ValueType_ValueType_STRING  ValueType = 0
	ValueType_ValueType_BOOL    ValueType = 1
	ValueType_ValueType_INT64   ValueType = 2
	ValueType_ValueType_FLOAT64 ValueType = 3
	ValueType_ValueType_BINARY  ValueType = 4
)

var ValueType_name = map[int32]string{
	0: "ValueType_STRING",
	1: "ValueType_BOOL",
	2: "ValueType_INT64",
	3: "ValueType_FLOAT64",
	4: "ValueType_BINARY",
}
var ValueType_value = map[string]int32{
	"ValueType_STRING":  0,
	"ValueType_BOOL":    1,
	"ValueType_INT64":   2,
	"ValueType_FLOAT64": 3,
	"ValueType_BINARY":  4,
}

func (x ValueType) String() string {
	return proto1.EnumName(ValueType_name, int32(x))
}
func (ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type DependencyLink struct {
	Parent    string `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	Child     string `protobuf:"bytes,2,opt,name=child" json:"child,omitempty"`
	CallCount uint64 `protobuf:"varint,3,opt,name=call_count,json=callCount" json:"call_count,omitempty"`
}

func (m *DependencyLink) Reset()                    { *m = DependencyLink{} }
func (m *DependencyLink) String() string            { return proto1.CompactTextString(m) }
func (*DependencyLink) ProtoMessage()               {}
func (*DependencyLink) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *DependencyLink) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *DependencyLink) GetChild() string {
	if m != nil {
		return m.Child
	}
	return ""
}

func (m *DependencyLink) GetCallCount() uint64 {
	if m != nil {
		return m.CallCount
	}
	return 0
}

type TraceId struct {
	Low  uint64 `protobuf:"varint,1,opt,name=low" json:"low,omitempty"`
	High uint64 `protobuf:"varint,2,opt,name=high" json:"high,omitempty"`
}

func (m *TraceId) Reset()                    { *m = TraceId{} }
func (m *TraceId) String() string            { return proto1.CompactTextString(m) }
func (*TraceId) ProtoMessage()               {}
func (*TraceId) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *TraceId) GetLow() uint64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *TraceId) GetHigh() uint64 {
	if m != nil {
		return m.High
	}
	return 0
}

type SpanRef struct {
	TraceId *TraceId    `protobuf:"bytes,1,opt,name=trace_id,json=traceId" json:"trace_id,omitempty"`
	SpanId  uint64      `protobuf:"varint,2,opt,name=span_id,json=spanId" json:"span_id,omitempty"`
	RefType SpanRefType `protobuf:"varint,3,opt,name=ref_type,json=refType,enum=proto.SpanRefType" json:"ref_type,omitempty"`
}

func (m *SpanRef) Reset()                    { *m = SpanRef{} }
func (m *SpanRef) String() string            { return proto1.CompactTextString(m) }
func (*SpanRef) ProtoMessage()               {}
func (*SpanRef) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *SpanRef) GetTraceId() *TraceId {
	if m != nil {
		return m.TraceId
	}
	return nil
}

func (m *SpanRef) GetSpanId() uint64 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

func (m *SpanRef) GetRefType() SpanRefType {
	if m != nil {
		return m.RefType
	}
	return SpanRefType_SpanRefType_CHILD_OF
}

type KeyValue struct {
	Key          string    `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	ValueType    ValueType `protobuf:"varint,2,opt,name=value_type,json=valueType,enum=proto.ValueType" json:"value_type,omitempty"`
	StringValue  string    `protobuf:"bytes,3,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	BoolValue    bool      `protobuf:"varint,4,opt,name=bool_value,json=boolValue" json:"bool_value,omitempty"`
	Int64Value   int64     `protobuf:"varint,5,opt,name=int64_value,json=int64Value" json:"int64_value,omitempty"`
	Float64Value float64   `protobuf:"fixed64,6,opt,name=float64_value,json=float64Value" json:"float64_value,omitempty"`
	BinaryValue  []byte    `protobuf:"bytes,7,opt,name=binary_value,json=binaryValue,proto3" json:"binary_value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto1.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValueType() ValueType {
	if m != nil {
		return m.ValueType
	}
	return ValueType_ValueType_STRING
}

func (m *KeyValue) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

func (m *KeyValue) GetBoolValue() bool {
	if m != nil {
		return m.BoolValue
	}
	return false
}

func (m *KeyValue) GetInt64Value() int64 {
	if m != nil {
		return m.Int64Value
	}
	return 0
}

func (m *KeyValue) GetFloat64Value() float64 {
	if m != nil {
		return m.Float64Value
	}
	return 0
}

func (m *KeyValue) GetBinaryValue() []byte {
	if m != nil {
		return m.BinaryValue
	}
	return nil
}

type Log struct {
	Timestamp *Timestamp  `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Fields    []*KeyValue `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto1.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *Log) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Log) GetFields() []*KeyValue {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Process struct {
	ServiceName string      `protobuf:"bytes,1,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
	Tags        []*KeyValue `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto1.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *Process) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Process) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

type TraceProcessMapping struct {
	ProcessId string   `protobuf:"bytes,1,opt,name=process_id,json=processId" json:"process_id,omitempty"`
	Process   *Process `protobuf:"bytes,2,opt,name=process" json:"process,omitempty"`
}

func (m *TraceProcessMapping) Reset()                    { *m = TraceProcessMapping{} }
func (m *TraceProcessMapping) String() string            { return proto1.CompactTextString(m) }
func (*TraceProcessMapping) ProtoMessage()               {}
func (*TraceProcessMapping) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *TraceProcessMapping) GetProcessId() string {
	if m != nil {
		return m.ProcessId
	}
	return ""
}

func (m *TraceProcessMapping) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

type Span struct {
	TraceId       *TraceId    `protobuf:"bytes,1,opt,name=trace_id,json=traceId" json:"trace_id,omitempty"`
	SpanId        uint64      `protobuf:"varint,2,opt,name=span_id,json=spanId" json:"span_id,omitempty"`
	OperationName string      `protobuf:"bytes,3,opt,name=operation_name,json=operationName" json:"operation_name,omitempty"`
	References    []*SpanRef  `protobuf:"bytes,4,rep,name=references" json:"references,omitempty"`
	Flags         uint32      `protobuf:"varint,5,opt,name=flags" json:"flags,omitempty"`
	StartTime     *Timestamp  `protobuf:"bytes,6,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	Duration      *Duration   `protobuf:"bytes,7,opt,name=duration" json:"duration,omitempty"`
	Tags          []*KeyValue `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	Logs          []*Log      `protobuf:"bytes,9,rep,name=logs" json:"logs,omitempty"`
	Process       *Process    `protobuf:"bytes,10,opt,name=process" json:"process,omitempty"`
	ProcessId     string      `protobuf:"bytes,11,opt,name=process_id,json=processId" json:"process_id,omitempty"`
	Warnings      []string    `protobuf:"bytes,12,rep,name=warnings" json:"warnings,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto1.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *Span) GetTraceId() *TraceId {
	if m != nil {
		return m.TraceId
	}
	return nil
}

func (m *Span) GetSpanId() uint64 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

func (m *Span) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

func (m *Span) GetReferences() []*SpanRef {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *Span) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Span) GetStartTime() *Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Span) GetDuration() *Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *Span) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Span) GetLogs() []*Log {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *Span) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *Span) GetProcessId() string {
	if m != nil {
		return m.ProcessId
	}
	return ""
}

func (m *Span) GetWarnings() []string {
	if m != nil {
		return m.Warnings
	}
	return nil
}

type Trace struct {
	Spans      []*Span                `protobuf:"bytes,1,rep,name=spans" json:"spans,omitempty"`
	ProcessMap []*TraceProcessMapping `protobuf:"bytes,2,rep,name=process_map,json=processMap" json:"process_map,omitempty"`
	Warnings   []string               `protobuf:"bytes,3,rep,name=warnings" json:"warnings,omitempty"`
}

func (m *Trace) Reset()                    { *m = Trace{} }
func (m *Trace) String() string            { return proto1.CompactTextString(m) }
func (*Trace) ProtoMessage()               {}
func (*Trace) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *Trace) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *Trace) GetProcessMap() []*TraceProcessMapping {
	if m != nil {
		return m.ProcessMap
	}
	return nil
}

func (m *Trace) GetWarnings() []string {
	if m != nil {
		return m.Warnings
	}
	return nil
}

// NOTE(olivierboucher): would rather use google's wrappers but given the current context its easier
type Timestamp struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	Nanos   int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto1.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

// NOTE(olivierboucher): would rather use google's wrappers but given the current context its easier
type Duration struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	Nanos   int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
}

func (m *Duration) Reset()                    { *m = Duration{} }
func (m *Duration) String() string            { return proto1.CompactTextString(m) }
func (*Duration) ProtoMessage()               {}
func (*Duration) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *Duration) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Duration) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

func init() {
	proto1.RegisterType((*DependencyLink)(nil), "proto.DependencyLink")
	proto1.RegisterType((*TraceId)(nil), "proto.TraceId")
	proto1.RegisterType((*SpanRef)(nil), "proto.SpanRef")
	proto1.RegisterType((*KeyValue)(nil), "proto.KeyValue")
	proto1.RegisterType((*Log)(nil), "proto.Log")
	proto1.RegisterType((*Process)(nil), "proto.Process")
	proto1.RegisterType((*TraceProcessMapping)(nil), "proto.TraceProcessMapping")
	proto1.RegisterType((*Span)(nil), "proto.Span")
	proto1.RegisterType((*Trace)(nil), "proto.Trace")
	proto1.RegisterType((*Timestamp)(nil), "proto.Timestamp")
	proto1.RegisterType((*Duration)(nil), "proto.Duration")
	proto1.RegisterEnum("proto.SpanRefType", SpanRefType_name, SpanRefType_value)
	proto1.RegisterEnum("proto.ValueType", ValueType_name, ValueType_value)
}

func init() { proto1.RegisterFile("model.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 814 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x5d, 0x6f, 0xdc, 0x44,
	0x14, 0xad, 0x63, 0xef, 0xda, 0xbe, 0xde, 0x6c, 0xcd, 0x34, 0x80, 0x55, 0x51, 0x70, 0x8c, 0x10,
	0xa6, 0x88, 0x54, 0x0a, 0x55, 0x1f, 0xe8, 0x53, 0xdb, 0xb0, 0xb0, 0xc2, 0xd9, 0x85, 0xc9, 0x0a,
	0xc4, 0x03, 0xb5, 0x26, 0xf6, 0xac, 0x63, 0xd5, 0x3b, 0x63, 0xd9, 0x4e, 0xa2, 0x95, 0x78, 0xe3,
	0x87, 0xf1, 0xb7, 0x78, 0x44, 0xf3, 0xe1, 0xfd, 0x88, 0x20, 0x12, 0x12, 0x4f, 0x99, 0x7b, 0xee,
	0x99, 0xe3, 0x3b, 0xf7, 0x9c, 0x2c, 0x78, 0x2b, 0x9e, 0xd3, 0xea, 0xa4, 0x6e, 0x78, 0xc7, 0xd1,
	0x40, 0xfe, 0x89, 0x7e, 0x83, 0xf1, 0x19, 0xad, 0x29, 0xcb, 0x29, 0xcb, 0xd6, 0x49, 0xc9, 0xde,
	0xa1, 0x0f, 0x60, 0x58, 0x93, 0x86, 0xb2, 0x2e, 0x30, 0x42, 0x23, 0x76, 0xb1, 0xae, 0xd0, 0x11,
	0x0c, 0xb2, 0xab, 0xb2, 0xca, 0x83, 0x03, 0x09, 0xab, 0x02, 0x3d, 0x01, 0xc8, 0x48, 0x55, 0xa5,
	0x19, 0xbf, 0x66, 0x5d, 0x60, 0x86, 0x46, 0x6c, 0x61, 0x57, 0x20, 0x6f, 0x04, 0x10, 0x3d, 0x03,
	0x7b, 0xd1, 0x90, 0x8c, 0x4e, 0x73, 0xe4, 0x83, 0x59, 0xf1, 0x5b, 0x29, 0x6a, 0x61, 0x71, 0x44,
	0x08, 0xac, 0xab, 0xb2, 0xb8, 0x92, 0x82, 0x16, 0x96, 0xe7, 0xe8, 0x77, 0xb0, 0x2f, 0x6a, 0xc2,
	0x30, 0x5d, 0xa2, 0x2f, 0xc0, 0xe9, 0xc4, 0xdd, 0xb4, 0xcc, 0xe5, 0x2d, 0xef, 0x74, 0xac, 0x66,
	0x3f, 0xd1, 0x92, 0xd8, 0xee, 0xb4, 0xf6, 0x87, 0x60, 0xb7, 0x35, 0x61, 0x82, 0xa9, 0xc4, 0x86,
	0xa2, 0x9c, 0xe6, 0xe8, 0x2b, 0x70, 0x1a, 0xba, 0x4c, 0xbb, 0x75, 0x4d, 0xe5, 0x70, 0xe3, 0x53,
	0xa4, 0x35, 0xf4, 0x57, 0x16, 0xeb, 0x9a, 0x62, 0xbb, 0x51, 0x87, 0xe8, 0x2f, 0x03, 0x9c, 0x1f,
	0xe8, 0xfa, 0x67, 0x52, 0x5d, 0x53, 0x31, 0xf0, 0x3b, 0xba, 0xd6, 0x5b, 0x10, 0x47, 0xf4, 0x0c,
	0xe0, 0x46, 0xb4, 0x94, 0xde, 0x81, 0xd4, 0xf3, 0xb5, 0x9e, 0xbc, 0x23, 0xd5, 0xdc, 0x9b, 0xfe,
	0x88, 0x8e, 0x61, 0xd4, 0x76, 0x4d, 0xc9, 0x8a, 0x54, 0x62, 0x72, 0x04, 0x17, 0x7b, 0x0a, 0x53,
	0x5f, 0x79, 0x02, 0x70, 0xc9, 0x79, 0xa5, 0x09, 0x56, 0x68, 0xc4, 0x0e, 0x76, 0x05, 0xa2, 0xda,
	0x9f, 0x80, 0x57, 0xb2, 0xee, 0xc5, 0x73, 0xdd, 0x1f, 0x84, 0x46, 0x6c, 0x62, 0x90, 0x90, 0x22,
	0x7c, 0x0a, 0x87, 0xcb, 0x8a, 0x93, 0x2d, 0x65, 0x18, 0x1a, 0xb1, 0x81, 0x47, 0x1a, 0x54, 0xa4,
	0x63, 0x18, 0x5d, 0x96, 0x8c, 0x34, 0x6b, 0xcd, 0xb1, 0x43, 0x23, 0x1e, 0x61, 0x4f, 0x61, 0x92,
	0x12, 0xbd, 0x05, 0x33, 0xe1, 0x05, 0x3a, 0x01, 0xb7, 0x2b, 0x57, 0xb4, 0xed, 0xc8, 0xaa, 0xd6,
	0x5b, 0xef, 0x5f, 0xb8, 0xe8, 0x71, 0xbc, 0xa5, 0xa0, 0xcf, 0x61, 0xb8, 0x2c, 0x69, 0x95, 0xb7,
	0xc1, 0x41, 0x68, 0xc6, 0xde, 0xe9, 0x43, 0x4d, 0xee, 0xb7, 0x88, 0x75, 0x3b, 0xfa, 0x09, 0xec,
	0x1f, 0x1b, 0x9e, 0xd1, 0xb6, 0x95, 0x5b, 0xa1, 0xcd, 0x4d, 0x99, 0xd1, 0x94, 0x91, 0x15, 0xd5,
	0x1b, 0xf6, 0x34, 0x36, 0x23, 0x2b, 0xf1, 0x2a, 0xab, 0x23, 0xc5, 0xbf, 0x8a, 0xca, 0x66, 0xf4,
	0x16, 0x1e, 0xc9, 0x24, 0x68, 0xdd, 0x73, 0x52, 0xd7, 0x25, 0x2b, 0xc4, 0x46, 0x6b, 0x85, 0xf4,
	0xc9, 0x71, 0xb1, 0xab, 0x91, 0x69, 0x8e, 0x62, 0xb0, 0x75, 0x21, 0x1d, 0xdc, 0xa6, 0x4a, 0xcb,
	0xe0, 0xbe, 0x1d, 0xfd, 0x69, 0x82, 0x25, 0x62, 0xf2, 0xbf, 0x24, 0xf1, 0x33, 0x18, 0xf3, 0x9a,
	0x36, 0xa4, 0x2b, 0x39, 0x53, 0xcf, 0x56, 0x61, 0x38, 0xdc, 0xa0, 0xf2, 0xe1, 0x27, 0x00, 0x0d,
	0x5d, 0xd2, 0x86, 0xb2, 0x8c, 0xb6, 0x81, 0x25, 0x9f, 0x3f, 0xde, 0x8f, 0x2c, 0xde, 0x61, 0x88,
	0xff, 0xca, 0x65, 0x25, 0x36, 0x25, 0x92, 0x71, 0x88, 0x55, 0x21, 0x82, 0xda, 0x76, 0xa4, 0xe9,
	0x52, 0x61, 0x94, 0x4c, 0xc4, 0x3f, 0xda, 0x28, 0x39, 0xa2, 0x46, 0x5f, 0x82, 0x93, 0x5f, 0xab,
	0x31, 0x64, 0x38, 0xb6, 0x3b, 0x3f, 0xd3, 0x30, 0xde, 0x10, 0x36, 0xe6, 0x38, 0xf7, 0x98, 0x83,
	0x3e, 0x06, 0xab, 0xe2, 0x45, 0x1b, 0xb8, 0x92, 0x04, 0x9a, 0x94, 0xf0, 0x02, 0x4b, 0x7c, 0xd7,
	0x06, 0xb8, 0xd7, 0x86, 0x3b, 0x7e, 0x7a, 0x77, 0xfd, 0x7c, 0x0c, 0xce, 0x2d, 0x69, 0x58, 0xc9,
	0x8a, 0x36, 0x18, 0x85, 0x66, 0xec, 0xe2, 0x4d, 0x1d, 0xfd, 0x61, 0xc0, 0x40, 0x5a, 0x84, 0x8e,
	0x61, 0x20, 0x8c, 0x68, 0x03, 0x43, 0xce, 0xe3, 0xed, 0xae, 0x54, 0x75, 0xd0, 0x4b, 0xf0, 0xfa,
	0xef, 0xac, 0x48, 0xad, 0xa3, 0xf7, 0x78, 0xd7, 0xe8, 0xfd, 0xa0, 0xe1, 0x7e, 0xac, 0x73, 0x52,
	0xef, 0x4d, 0x61, 0xde, 0x99, 0xe2, 0x25, 0xb8, 0x9b, 0xa5, 0xa3, 0x00, 0xec, 0x96, 0x66, 0x9c,
	0xe5, 0xad, 0x8c, 0x92, 0x89, 0xfb, 0x52, 0x58, 0xc9, 0x08, 0xe3, 0x2a, 0x96, 0x03, 0xac, 0x8a,
	0xe8, 0x1b, 0x70, 0x7a, 0x0b, 0xfe, 0xeb, 0xdd, 0xa7, 0xdf, 0x82, 0xb7, 0xf3, 0x33, 0x87, 0x02,
	0x38, 0xda, 0x29, 0xd3, 0x37, 0xdf, 0x4f, 0x93, 0xb3, 0x74, 0x3e, 0xf1, 0x1f, 0xa0, 0x8f, 0x20,
	0xd8, 0xed, 0x4c, 0xe6, 0x49, 0x32, 0xff, 0xe5, 0x22, 0x9d, 0xe0, 0xf9, 0xb9, 0x6f, 0x3c, 0xbd,
	0x05, 0x77, 0xf3, 0xeb, 0x86, 0x8e, 0xc0, 0xdf, 0x14, 0xe9, 0xc5, 0x02, 0x4f, 0x67, 0xdf, 0xf9,
	0x0f, 0x10, 0x82, 0xf1, 0x16, 0x7d, 0x3d, 0x9f, 0x27, 0xbe, 0x81, 0x1e, 0xc1, 0xc3, 0x2d, 0x36,
	0x9d, 0x2d, 0x5e, 0x3c, 0xf7, 0x0f, 0xd0, 0xfb, 0xf0, 0xde, 0x16, 0x9c, 0x24, 0xf3, 0x57, 0x02,
	0x36, 0xf7, 0x55, 0x5f, 0x4f, 0x67, 0xaf, 0xf0, 0xaf, 0xbe, 0x75, 0x39, 0x94, 0xbb, 0xff, 0xfa,
	0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x21, 0xa8, 0x9a, 0x4f, 0xb9, 0x06, 0x00, 0x00,
}
