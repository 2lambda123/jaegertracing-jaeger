import json
import json


def generate_markdown_table(metrics, title):
    """
    Generates a markdown table for the given metrics.

    Args:
        metrics (dict): The dictionary of metrics.
        title (str): The title of the metrics group.

    Returns:
        str: The generated markdown table as a string.
    """
    table = f"### {title}\n\n"
    table += "| Metric Name | Inner Parameters |\n"
    table += "|-------------|------------------|\n"

    for metric_name, inner_params in metrics.items():
        # Extract the keys of the inner parameters, if any
        inner_keys = ', '.join(inner_params.keys()) if inner_params else ''
        table += f"| {metric_name} | {inner_keys} |\n"

    return table

def generate_spans_markdown_table(v1_spans, v2_spans):
    """
    Generates a markdown table specifically for spans metrics with two main columns V1 and V2.

    Args:
        v1_spans (dict): The dictionary of V1 spans metrics.
        v2_spans (dict): The dictionary of V2 spans metrics.

    Returns:
        str: The generated markdown table as a string.
    """
    table = "### Equivalent Metrics\n\n"
    table += "| V1 Metric | V1 Parameters | V2 Metric | V2 Parameters |\n"
    table += "|-----------|---------------|-----------|---------------|\n"

    # Get the maximum length of the spans to align the table rows
    max_len = max(len(v1_spans), len(v2_spans))

    # Iterate through the metrics using zip_longest to handle mismatched lengths
    from itertools import zip_longest

    for (v1_metric, v1_params), (v2_metric, v2_params) in zip_longest(v1_spans.items(), v2_spans.items(), fillvalue=('', {})):
        v1_inner_keys = ', '.join(v1_params.keys()) if v1_params else ''
        v2_inner_keys = ', '.join(v2_params.keys()) if v2_params else ''
        table += f"| {v1_metric} | {v1_inner_keys} | {v2_metric} | {v2_inner_keys} |\n"

    return table

class Convert_Json():

    def __init__(self, json_fp, h1):
        self.fp = json_fp
        self.h1 = h1
        self.jdata = self.get_json()
        self.mddata = self.format_json_to_md()

    def get_json(self):
        with open(self.fp) as f:
            res = json.load(f)
        return res

    def format_json_to_md(self):
        text = f'# {self.h1}\n'
        dct = self.jdata
        print(dct)
        common_metrics_table = generate_markdown_table(dct["common_metrics"], "Common Metrics")
        v1_metrics_table = generate_markdown_table(dct["v1_only_metrics"], "V1 Only Metrics")
        v2_metrics_table = generate_markdown_table(dct["v2_only_metrics"], "V2 Only Metrics")


        filtered_v1_metrics = {}
        for metric, params in dct["v1_only_metrics"].items():
           if "jaeger_collector_spans_rejected_total" in metric:
                filtered_v1_metrics[metric] = params

        filtered_v2_metrics = {}
        for metric, params in dct["v2_only_metrics"].items():
           if "receiver_refused_spans" in metric:
               filtered_v2_metrics[metric] = params
        spans_metrics_table = generate_spans_markdown_table(filtered_v1_metrics, filtered_v2_metrics)
       
        text=common_metrics_table+v1_metrics_table+v2_metrics_table+spans_metrics_table
        return text

    def convert_dict_to_md(self, output_fn):
        with open(output_fn, 'w') as writer:
            writer.writelines(self.mddata)
        print('Dict successfully converted to md')


# Convert the JSON generated by compare_metrics.py to markdown
fn = 'differences.json'
title = "TITLE"
converter = Convert_Json(fn, title)
converter.convert_dict_to_md(output_fn='metrics.md')